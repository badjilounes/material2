{"version":3,"file":"focus-classes.js","sourceRoot":"","sources":["../../../../../src/lib/core/style/focus-classes.ts"],"names":[],"mappings":"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","sourcesContent":["import {Directive, Injectable, Optional, SkipSelf, Renderer, ElementRef} from '@angular/core';\n\n\nexport type FocusOrigin = 'mouse' | 'keyboard' | 'program';\n\n\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\n@Injectable()\nexport class FocusOriginMonitor {\n  /** The focus origin that the next focus event is a result of. */\n  private _origin: FocusOrigin = null;\n\n  constructor() {\n    // Listen to keydown and mousedown in the capture phase so we can detect them even if the user\n    // stops propagation.\n    // TODO(mmalerba): Figure out how to handle touchstart\n    document.addEventListener(\n        'keydown', () => this._setOriginForCurrentEventQueue('keyboard'), true);\n    document.addEventListener(\n        'mousedown', () => this._setOriginForCurrentEventQueue('mouse'), true);\n  }\n\n  /** Register an element to receive focus classes. */\n  registerElementForFocusClasses(element: Element, renderer: Renderer) {\n    renderer.listen(element, 'focus', () => this._onFocus(element, renderer));\n    renderer.listen(element, 'blur', () => this._onBlur(element, renderer));\n  }\n\n  /** Focuses the element via the specified focus origin. */\n  focusVia(element: Node, renderer: Renderer, origin: FocusOrigin) {\n    this._setOriginForCurrentEventQueue(origin);\n    renderer.invokeElementMethod(element, 'focus');\n  }\n\n  /** Sets the origin and schedules an async function to clear it at the end of the event queue. */\n  private _setOriginForCurrentEventQueue(origin: FocusOrigin) {\n    this._origin = origin;\n    setTimeout(() => this._origin = null, 0);\n  }\n\n  /** Handles focus events on a registered element. */\n  private _onFocus(element: Element, renderer: Renderer) {\n    renderer.setElementClass(element, 'cdk-focused', true);\n    renderer.setElementClass(element, 'cdk-keyboard-focused', this._origin == 'keyboard');\n    renderer.setElementClass(element, 'cdk-mouse-focused', this._origin == 'mouse');\n    renderer.setElementClass(element, 'cdk-program-focused',\n        !this._origin || this._origin == 'program');\n    this._origin = null;\n  }\n\n  /** Handles blur events on a registered element. */\n  private _onBlur(element: Element, renderer: Renderer) {\n    renderer.setElementClass(element, 'cdk-focused', false);\n    renderer.setElementClass(element, 'cdk-keyboard-focused', false);\n    renderer.setElementClass(element, 'cdk-mouse-focused', false);\n    renderer.setElementClass(element, 'cdk-program-focused', false);\n  }\n}\n\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, or\n * programmatically) and adds corresponding classes to the element.\n */\n@Directive({\n  selector: '[cdkFocusClasses]',\n})\nexport class CdkFocusClasses {\n  constructor(elementRef: ElementRef, focusOriginMonitor: FocusOriginMonitor, renderer: Renderer) {\n    focusOriginMonitor.registerElementForFocusClasses(elementRef.nativeElement, renderer);\n  }\n}\n\n\nexport function FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher: FocusOriginMonitor) {\n  return parentDispatcher || new FocusOriginMonitor();\n}\n\n\nexport const FOCUS_ORIGIN_MONITOR_PROVIDER = {\n  // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.\n  provide: FocusOriginMonitor,\n  deps: [[new Optional(), new SkipSelf(), FocusOriginMonitor]],\n  useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\n};\n"]}